using System.Collections.Generic;
using System;
using System.Linq;
using WinttOS.wSystem.Utils;

namespace WinttOS.wSystem.Shell.Programs
{
    public static class MiniDiff
    {
        
        /// <summary>
        /// Generates simple diff with first line being origin file, second new version
        /// </summary>
        /// <param name="file1">Conetns of original file splitted with \n</param>
        /// <param name="file2">Conetns of new version of file splitted with \n</param>
        /// <param name="file1Path">Path to original file</param>
        /// <param name="file2Path">Path to new version of file</param>
        /// <returns>A list of strings which can be combines with '\n' separator and stored to file</returns>
        public static List<string> GetDifferences(string[] file1, string[] file2, string file1Path, string file2Path)
        {
            List<string> diffOutput = new List<string>
            {
                $"--- {file1Path}",
                $"+++ {file2Path}"
            };

            int m = file1.Length;
            int n = file2.Length;

            Flat2DArrayInt32 dp = new(m + 1, n + 1);

            for (int i = 0; i <= m; i++)
            {
                for (int j = 0; j <= n; j++)
                {
                    if (i == 0 || j == 0)
                    {
                        dp[i, j] = 0;
                    }
                    else if (file1[i - 1] == file2[j - 1])
                    {
                        dp[i, j] = dp[i - 1, j - 1] + 1;
                    }
                    else
                    {
                        dp[i, j] = Math.Max(dp[i - 1, j], dp[i, j - 1]);
                    }
                }
            }

            int index1 = m, index2 = n;
            List<string> chunk = new List<string>();
            int chunkStart1 = -1, chunkStart2 = -1;
            int removedLines = 0, addedLines = 0;

            while (index1 > 0 || index2 > 0)
            {
                if (index1 > 0 && index2 > 0 && file1[index1 - 1] == file2[index2 - 1])
                {
                    if (chunk.Count > 0)
                    {
                        diffOutput.Add($"@@ -{chunkStart1 + 1},{removedLines} +{chunkStart2 + 1},{addedLines} @@");
                        diffOutput.AddRange(chunk);
                        chunk.Clear();
                        removedLines = 0;
                        addedLines = 0;
                        chunkStart1 = -1;
                        chunkStart2 = -1;
                    }
                    index1--;
                    index2--;
                }
                else
                {
                    if (chunkStart1 == -1 || chunkStart2 == -1)
                    {
                        chunkStart1 = index1 - 1;
                        chunkStart2 = index2 - 1;
                    }

                    if (index1 > 0 && (index2 == 0 || dp[index1 - 1, index2] >= dp[index1, index2 - 1]))
                    {
                        chunk.Insert(0, $"- {file1[index1 - 1]}");
                        index1--;
                        removedLines++;
                    }
                    else if (index2 > 0)
                    {
                        chunk.Insert(0, $"+ {file2[index2 - 1]}");
                        index2--;
                        addedLines++;
                    }
                }
            }

            if (chunk.Count > 0)
            {
                diffOutput.Add($"@@ -{chunkStart1 + 1},{removedLines} +{chunkStart2 + 1},{addedLines} @@");
                diffOutput.AddRange(chunk);
            }

            return diffOutput;
        }
        
        /// <summary>
        /// Applies patch to <paramref name="targetFileContent"/> from Diff created by <see cref="GetDifferences(string[], string[], string, string)"/>
        /// </summary>
        /// <param name="patchFileContent">Diff generated by <see cref="GetDifferences(string[], string[], string, string)"/></param>
        /// <param name="targetFileContent">Original file content to apply patch to</param>
        /// <returns>A list of strings which can be combines with '\n' separator and stored to file</returns>
        public static List<string> ApplyPatch(string patchFileContent, string targetFileContent)
        {
            var patchLines = new List<string>(patchFileContent.Split('\n')).Skip(2).ToArray();
            var targetLines = new List<string>(targetFileContent.Split('\n'));

            var targetDict = new Dictionary<int, string>();
            for (int i = 0; i < targetLines.Count; i++)
            {
                targetDict[i + 1] = targetLines[i];
            }

            int currentLine = 1;
            foreach (var patchLine in patchLines)
            {
                if (patchLine.StartsWith("@@"))
                {
                    var parts = patchLine.Split(new[] { ' ', '@', '-', ',', '+' }, StringSplitOptions.RemoveEmptyEntries);
                    if (parts.Length >= 4)
                    {
                        currentLine = int.Parse(parts[2]);
                    }
                    continue;
                }

                if (patchLine.StartsWith("-"))
                {
                    string lineToRemove = patchLine.Substring(2);
                    int lineNumToRemove = -1;
                    foreach (var entry in targetDict)
                    {
                        if (entry.Value == lineToRemove)
                        {
                            lineNumToRemove = entry.Key;
                            break;
                        }
                    }

                    if (lineNumToRemove != -1)
                    {
                        targetDict.Remove(lineNumToRemove);
                    }
                }
                else if (patchLine.StartsWith("+"))
                {
                    string lineToAdd = patchLine.Substring(2);
                    targetDict[currentLine] = lineToAdd;
                    currentLine++;
                }
                else
                {
                    currentLine++;
                }
            }

            var newTargetLines = new List<string>(targetDict.Values);
            return newTargetLines;
        }
    }
}
